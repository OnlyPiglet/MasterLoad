

# 架构师成长之路

## 前言
借用一下一张图

![如侵必删](./img/previous.PNG)

#  架构师筑基必备技能
## 并发编程进阶

### 线程共享和协作

1. CPU核心数，线程数，时间片轮转机制解读

  

  - CPU核心数 

    CPU核心数分为 物理CPU，单CPU上的核心数，以及逻辑CPU，具体区别可以查询[CPU逻辑核心数和物理核心数是什么意思?](https://zhidao.baidu.com/question/568786289.html)	在Java 中可以通过 ```Runtime.getRuntime().availableProcessors()``` 获取为逻辑CPU的数量为我们所说的CPU核心数。

  - 线程数 线程是CPU可以调度的最小单元，对于多线程线程数量的合理设置就显得很关键了，线程数过少可能不能发挥CPU的全部效能，线程数过大又会产生上下文切换反而会降低效能。关于线程数量的设置，在我观察中一般有两种策略，一种较为笼统简单，还有一种较为精准，首先谈第一种策略

    ##### 简单策略

    将CPU的效能转换为完成任务所需时间，用时越少代表效能越高，设定```任务所需用时=CPU用时+IO用时```

    根据其中CPU用时和IO用时占比不同分为 CPU密集型 IO密集型。对用CPU密集型的任务，线程数设置为**CPU核心数+1**因为使用CPU的时间较多，不建议设置过多线程数，导致频繁切换上下文；对于IO密集型的线程数设置为**CPU核心数*2**，因为CPU会长时间处于空闲状态所以可以设置多一些线程数，增加CPU的使用效能。此种策略的简单方面有二，其一是设置线程数量的公式较为简陋，其二是没有考虑到系统的其他性能如文件句柄上限的数量等

    ##### 复杂策略

    可以参考[Programming Concurrency on the JVM](./books/Programming Concurrency on the JVM.pdf)中Page32的一段话

    ```
    Number of threads = Number of Available Cores / (1 - Blocking Coefficient)
    ```

    > where the blocking coefficient is between 0 and 1.
    >
    > A computation-intensive task has a blocking coefficient of 0, whereas an IO-intensive task has a value close to 1—a fully blocked task is doomed, so we don’t have to worry about the value reaching 1.
    >
    > To determine the number of threads, we need to know two things:
    >
    > • The number of available cores
    > • The blocking coefficient of tasks
    >
    > The first one is easy to determine; we can look up that information, even at runtime, as we saw earlier. It takes a bit of effort to determine the blocking coefficient. We can try to guess it, or we can use profiling tools or the java.lang.management API to determine the amount of time a thread spends on system/IO operations vs. on CPU-intensive tasks.

  ​      这里的```(Blocking Coefficient)阻塞系数=IO用时/CPU用时+IO用时```，这里还提到了可以使用```java.lang.management```包中的工具检测程序CPU的使用时间，相关的[ThreadMXBean API链接](https://docs.oracle.com/javase/8/docs/api/)我写了一个列子如代码清单1-1

  ```java
  import java.lang.management.ManagementFactory;
  import java.time.LocalTime;
  import java.util.concurrent.TimeUnit;
  
  public class TaskTest implements Runnable{
  
      private static volatile boolean loop = true;
  
      public void run() {
          LocalTime end = null;
          LocalTime start = LocalTime.now();
          int IOSUMTIME = 5;
          try{
              //CPU计算
              cal(1000000);
  
              //模拟IO用时
              TimeUnit.SECONDS.sleep(IOSUMTIME);
  
              end = LocalTime.now();
  
          }catch (Exception e) {
  
              e.fillInStackTrace();
  
          }finally {
              System.out.println("总计耗时: " +( end.toNanoOfDay() - start.toNanoOfDay() / 1000000000.0) + "s");
              double total_cpu = ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime()/1000000000.0;
              double user_cpu = ManagementFactory.getThreadMXBean().getCurrentThreadUserTime()/1000000000.0;
              System.out.println("总CPU耗时: " + total_cpu + "s");
              System.out.println("用户态CPU耗时: "+user_cpu +"s");
              System.out.println("IO耗时:"+IOSUMTIME+"s");
              double block_efficent = IOSUMTIME/(IOSUMTIME+total_cpu);
              System.out.println("阻塞系数: "+block_efficent);
              int cores = Runtime.getRuntime().availableProcessors();
              System.out.println("系统可用逻辑CPU核心数量:" + cores);
              System.out.println("此任务最佳线程数: " + cores/(1-block_efficent));
  
          }
  
  
      }
  
  
      public void cal(long lopp_cyc){
  
          double sum = 0;
  
          for(int i = 0;i<lopp_cyc;i++){
  
              sum = sum + i * i + Math.pow(2.0,Double.valueOf(i));
  
          }
  
      }
  }
  ```

  <center>代码清单1-1</center>
  运行结果如下

  ```
  总计耗时: 7.2238589927767E13s
  总CPU耗时: 0.71567s
  用户态CPU耗时: 0.702647s
  IO耗时:5s
  阻塞系数: 0.8747880825869933
  系统可用逻辑CPU核心数量:4
  此任务最佳线程数: 31.945840960219083
  ```

* 时间片轮转机制

  时间片轮转机制即单个CPU核心会不停的切换不同的线程，进程进行运行，由此产生了上文所说的上下文切换的问题。

2. synchronized/volatile/ThreadLocal

  [Java8全部官方文档](https://docs.oracle.com/javase/8/docs/)

  * synchronized

    **原子性 顺序性 可见性**

    **可重入**

    [Chapter17.1 Synchronization](./books/jls8.pdf#page=660&zoom=100,0,89)

    > The Java programming language provides multiple mechanisms for
    > communicating between threads. The most basic of these methods is
    > synchronization, which is implemented using monitors. Each object in Java is
    > associated with a monitor, which a thread can lock or unlock. Only one thread at
    > a time may hold a lock on a monitor. Any other threads attempting to lock that
    > monitor are blocked until they can obtain a lock on that monitor. **A thread t may
    > lock a particular monitor multiple times; each unlock reverses the effect of one
    > lock operation.**

    此段文献中明确说明了同一个线程是可以对同一个监视器拿锁多次。**(Synchronization是可重入的)**

    [Chapter3.14 Synchronization底层实现细节](./books/jvms8.pdf)

    > Synchronization in the Java Virtual Machine is implemented by monitor entry and
> exit, either explicitly (by use of the monitorenter and monitorexit instructions) or
    > implicitly (by the method invocation and return instructions).
> For code written in the Java programming language, perhaps the most common
    > form of synchronization is the  synchronized method. **A  synchronized method is**
    > **not normally implemented using monitorenter and monitorexit. Rather, it is simply**
    > **distinguished in the run-time constant pool by the  ACC_SYNCHRONIZED flag, which**
    > **is checked by the method invocation instructions (§2.11.10).**



此段说明了对于同步代码块使用的是monitorenter 与 monitorexit ,但对于同步方法略有不同使用的是常量池里的ACC_SYNCHRONIZED 标志位辨别同步。

**死锁的发生**

1. 持有D锁的线程A在等待B锁，持有B锁的线程C在等待D锁，接下来通过代码演示

```java
   package thread_share;
       
   public class A_Task implements Runnable {
       private Object a;
   
       private Object c;
   
       public A_Task(Object a,Object c){
           this.a = a;
           this.c = c;
       }
   
       @Override
       public void run() {
   
           synchronized (a){
   
               Flag.A_Ready = true;
   
               System.out.println("A_Task get a");
   
               while(!Flag.A_Ready || !Flag.B_Ready){
   
               }
               synchronized (c){
   
                   System.out.println("A_Task get c");
   
               }
   
           }
   
       }
   }
```




​    
```java
 package thread_share;
 public class B_Task implements Runnable {
 	private Object a;

    private Object c;
    public B_Task(Object c,Object a){

        this.a = a ;
        this.c = c;

    }

    @Override
    public void run() {

        synchronized (c){

            Flag.B_Ready = true;

            System.out.println("B_Task get c");

            while(!Flag.A_Ready || !Flag.B_Ready){

            }
            synchronized (a){

                System.out.println("B_Task get a");

            }

        }

    }
}


```


​    
```java
package thread_share;
public class Flag {
	public static volatile boolean A_Ready = false;
    public static volatile boolean B_Ready = false;
}

```


​    
```java
 package thread_share;
 public  class Test {
 	public static void main(String[] args) {

        Object a = new Object();

        Object c = new Object();

        new Thread(new A_Task(a,c)).start();

        new Thread(new B_Task(c,a)).start();
  		    }
 }
```




最后的结果截图如下

![deadlock_1](./img/deadlock_1.png)

从结果中可以看出A_Task进展到拿对象c的锁这一步停滞不前，B_Task进展到到拿a的锁这一步停滞不前，原因就是发生死锁了。

知道了死锁如何避免死锁的

这里直接参考[死锁，死锁的四个必要条件以及处理策略](https://blog.csdn.net/wljliujuan/article/details/79614019)

死锁的四个必要条件为

#### 互斥条件：

进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

#### 不可剥夺条件:

进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

#### 请求与保持条件：

进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

#### 循环等待条件:预防死锁

存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。

直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。

Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。

#### 预防死锁

**以上这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。**

****

再次分析一下 互斥条件和不可剥夺 为synchronized 的实现原理无法改变，可以从请求与保持条件,循环等待条件

  * volatile

    顺序性 可见性

    [JMM模型](https://www.jianshu.com/p/47f999a7c280)

    Happen Before原则

    - 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。
  - 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。
    
    - volatile的happen-before原则：对一个volatile变量的读操作happen-before对此变量的任意操作(当然也包括写操作了)。
  - happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
    - 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。
    - 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
    - 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。
    - 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。
    
    
    32位机器上 Long和Double的写诗非原子操作，读在JSR133后是原子操作之前也是非原子操作，因为Long和Double是4字节64位

  * ThreadLocal

    Thread->ThreadLocalMap->Entry[]->Entry WeakReference<ThreadLocal<?>>->key->value

    死锁 内存泄露

    线程上下文事务回滚
    
    connection
    数据库连接池的应用
    
    #### Description
   ```java
    public class DaoTemplate{
    
    ThreadLocal<Connection> conection_local = new ThreadLocal<Connection>();
    
    private getConnction(){
    
       if(conection_local.get() == null){
          
          conection_local.set(ConnectionManager.getConection());
       
       }else{
       
       return conection_local.get();
       
       } 
    }
    private closeConnction(){   
        if(conection_local.get() != null){    
        conection_local.remove();
        }   
    }
    abstract void run(Connection connection);
    
    protected void bussiness(){
      try{ 
         run(getConnection());
      }catch(EXception e)
      {
        throw new SQLExcpetion();
      }finally{
        closeConnction();
      }
     }   
    }
   ```

3. wait/notify/notifyAll/Join

   wait/notify/notifyAll/Join 的底层实现也是基于mintoerenter 与 mointoerexit 所以必须要在同步代码块中进行使用  

### 线程池

#### 线程池的使用

[阿里云Java开发手册](./books/java.pdf)

#### 线程池底层原理

#### Executor原理

Executor 

Thread

ThreadFactory

ThreadPoolExecutor

Worker 

AbstractQueuedSynchronizer



AbortPolicy

DiscardPolicy

DiscardOldestPolicy



## JVM性能深度调优

## 网络编程与高效IO
### 零拷贝
![零拷贝](./img/io/zero-copy.png)

BIO NIO AIO

IO通信 分为两步 1. io请求发送  2. io的write read 

第一步请求方式的不同分为 阻塞 非阻塞

第二步 从app 到system io的write 和 read 不同分为 同步 异步



## 深入Tomcat底层

### 线程隔离

首先是双亲委派 这里就不再具体描述 直接上图了

![classloader](.\img\classloader\classloader.png)

相同限定名的类在JVM中其实并不一定时相同的，需要是同一个ClassLoder加载的才可以

class类的唯一标识 为ClassLoader+类的全限定名

```java
Thread.currentThread().getContextClassLoader()
```

会获取当前线程调用者的类加载器，其实在一个正常的应用中，创建线程对象的称为父线程，这样一直向上会找到main函数 的线程，程序的入口，所以一般情况下获取的为Application Classloader。

SPI(Service Provider Interface) 服务

Java中会在核心类中定义好一些服务的功能接口，具体实现由第三方按照一定的规则进行开发服务。

在META-INF/services/下编写文件文件名为接口类的全限定名，内容为第三方实现类的权限定名，多个实现类由换行符分割。

综合上面的内容其实我们自己开发spi服务还好，但是如果是java自己的spi服务就会出现一些问题，因为接口的加载ClassLoader为Boostrap ClassLoader，当使用接口获取第三方实现类的时候，会由Boostrap ClassLoader加载，但是第三方实现类是在classpath下，找不到，此时就需要打破原先的classloader，使用classpath loader加载实现类

具体一个实现例子为JDBC，当我们使用JDBC的DriverManager的getConnection获取连接时

```java
@CallerSensitivepublic static Connection getConnection(String url,    java.util.Properties info) throws SQLException {   
return (getConnection(url, info, Reflection.getCallerClass()));
}
```

```java
private static Connection getConnection(    String url, java.util.Properties info, Class<?> caller) throws SQLException {   
/*     * When callerCl is null, we should check the application's     
* (which is invoking this class indirectly)     
* classloader, so that the JDBC driver class outside rt.jar     
* can be loaded from here.     */    
        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;  
    synchronized(DriverManager.class) {       
// synchronize loading of the correct classloader.       
        if (callerCL == null) {           
            callerCL = Thread.currentThread().getContextClassLoader();     
        }    
    }    
    if(url == null) {
        throw new SQLException("The url cannot be null", "08001");   
    }    
    println("DriverManager.getConnection(\"" + url + "\")");    
    // Walk through the loaded registeredDrivers attempting to make a connection.   
    // Remember the first exception that gets raised so we can reraise it.  
    SQLException reason = null;    for(DriverInfo aDriver : registeredDrivers) {      
        // If the caller does not have permission to load the driver then      
        // skip it.       
        if(isDriverAllowed(aDriver.driver, callerCL)) {          
            try {              
                println("    trying " + aDriver.driver.getClass().getName());                
                Connection con = aDriver.driver.connect(url, info);               
                if (con != null) {                    
                    // Success!                    
                    println("getConnection returning " + aDriver.driver.getClass().getName()); 
                    return (con);               
                }            
            } catch (SQLException ex) {
                if (reason == null) {
                    reason = ex; 
                }            
            }        
        } else {            
            println("    skipping: " + aDriver.getClass().getName());       
        }    
    }
```

其中的关键为

```java
Reflection.getCallerClass()  

ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;  
synchronized(DriverManager.class) {       

// synchronize loading of the correct classloader.       
        if (callerCL == null) {           
            callerCL = Thread.currentThread().getContextClassLoader();     
        }    
    }    
```

因为DriverManager时Bootstrap Classloader加载的，所以```Reflection.getCallerClass()```为null，所以caller为null,所以将当前callerCL设置为ThreadContextClassLoader，最终为上层的ApplicationClassLoader所以可以加载同时ClassPath下的第三方实现类。

## MYSQL深度优化

MYSQL备份

mysqldump -hIP -pPORT -uUSERNAME -pPASSWORD DATABASENAME | gzip  >  BACKUPFILEPAT.gz

mysqldump -hIP -pPORT -uUSERNAME -pPASSWORD DATABASENAME <  BACKUPFILEPAT.sql

### MYSQL事务及隔离性级别

##### 参考

[何为脏读、不可重复读、幻读](http://ifeve.com/db_problem/)

##### 定义

事务是用于查询或修改数据库各项数据的最小执行单元

##### 特性

* 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。

* 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

* 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

* 持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

由于是最小的执行单元,所以天然具有原子性 与 一致性

持久性应该是属于数据库的特性,既然事务是对数据库各项数据的查询与修改那么也必然是具备持久性的

隔离性特性的产生的原因 有些类似于多线程共享资源的处理 但不完全一样,为了解决事务并发带来的问题，才有了事务规范中的四个事务隔离级别

有以下几种事务并发问题情况的出现

测试数据

```sql
insert into table value(1,5)
insert into table value(2,6)
insert into table value(3,3)
insert into table value(4,7)
```

1. 脏读

   ![脏读](./img/mysql/zangdu.png)

   是指一个事务读取到了其他事务没有提交的数据

   会话1在会话2 update 后读到的age为 10 ,但是 会话2 可能update 后 不commit 执行 rollback

2. 不可重复读

   ![不可重复读](./img/mysql/bukechongfudu.png)

   一个事务内多次根据同一个查询条件查询出来的同一行记录的值不一样

   会话1在第一次读到的age是5,然后会话2 update 为 10 并且 提交 会话1 再次读取 age变为 10 ,两次读取结果不一样

3. 幻读

   ![幻读](./img/mysql/huandu.png)

   一个事务内多次根据同个条件查出来的记录行数不一样

   会话1第一次查询结果为2,会话2 insert 新数据,会话1再次查询 结果为 3

##### 隔离级别与问题

针对隔离性各大数据库厂商有着自己的解决方案,主要有以下几种

```
TRANSACTION_NONE                  不支持事务
TRANSACTION_READ_COMMITTED        支持事务               不防止 脏读 不可重复读 幻读
TRANSACTION_READ_UNCOMMITTED      防脏读                不防止 不可重复读 幻读
TRANSACTION_REPEATABLE_READ       防脏读 不可重复读       不防止 幻读
TRANSACTION_SERIALIZABLE          防脏读 不可重复读 幻读
```

Mysql 在 防止不可重复读 是存在一些争议的

![不可重复读争议](./img/mysql/bukechongfuduzhengyi.png)

TODO

## 架构基础必备Linux

# 设计思想解读和开源框架

## 六大原则

## 结构型模式

## 创建型模式

## 行为型模式

## Spring5源码解读

### 源码下载安装

使用idea下载最新的Spring版本

进入spring-core目录执行下面两个命令

`gradle objenesisRepackJar`

`gradle cglibRepackJar`

因为spring-core模块依赖着两个包,但是这两个包饼没有被打包进来需要手动加入依赖

我们一定会用到spring-context模块,此时我们需要先修改spring-context模块的build.gradle将其中的 compile(project(":spring-aop"))注释,暂时用不到,还有将optional(project(":spring-instrument"))修改为compile(project(":spring-instrument"))

接下来开始第一次的
---

Spring IOC创建Bean对象

IOC中做重要的BeanFactory 定义了获取Bean对象功能，以及一些基本Bean属性判断的功能

如判断是否为单例，是否是原型创建模式，获取Bean的别名，获取BeanProvider , 其中还有一个特别的内容就是定义了

FactoryBean的BeanName前加上& 和他自己创建的Bean对象 区别 

```String FACTORY_BEAN_PREFIX = "&";```

这个的具体意思话不多说直接上案例和结果

实现 FactoryBean 

```java
@Componentpublic class BeanGenerateCase implements FactoryBean<String> {   
    @Override   public String getObject() throws Exception {      
        return "GeneratorObject";   
    }   
    @Override   
    public Class<?> getObjectType() {      
        return String.class;   
    }   
    @Override   
    public boolean isSingleton() {      
        return false;   
    }
}
```

获取FactoryBean

```java
public static void main(String[] args) {   
    AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext();   
    annotationConfigApplicationContext.scan("com.test");                  
    annotationConfigApplicationContext.refresh();       
    System.out.println(annotationConfigApplicationContext.getBean("beanGenerateCase"));   
    System.out.println(annotationConfigApplicationContext.getBean("&beanGenerateCase"));
}
```

结果为

`GeneratorObject`
`com.test.BeanGenerateCase@1b4fb997`

所以可以看出当Bean为FactoryBean及产生其他bean的bean的时候，他本身的beanname 需要在首字母小写的类名前加上取地址符号&才是class本身的Bean，没有加的取的是生成的bean





AbstractAutowireCapacleBeanFactory

```java
	/**
	 * Actually create the specified bean. Pre-creation processing has already happened
	 * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.
	 * <p>Differentiates between default bean instantiation, use of a
	 * factory method, and autowiring a constructor.
	 * @param beanName the name of the bean
	 * @param mbd the merged bean definition for the bean
	 * @param args explicit arguments to use for constructor or factory method invocation
	 * @return a new instance of the bean
	 * @throws BeanCreationException if the bean could not be created
	 * @see #instantiateBean
	 * @see #instantiateUsingFactoryMethod
	 * @see #autowireConstructor
	 */
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
            //如果时单例的 删除工厂缓存中的对象
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class<?> beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
			}
		}

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								"Bean with name '" + beanName + "' has been injected into other beans [" +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								"] in its raw version as part of a circular reference, but has eventually been " +
								"wrapped. This means that said other beans do not use the final version of the " +
								"bean. This is often the result of over-eager type matching - consider using " +
								"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
		}

		return exposedObject;
	}
```



普通的Bean对象

定义bean标签>将bean标签解析成BeanDefinition>调用无参构造实现对象放入




 定义bean标签>将bean标签解析成BeanDefinition>调用构造方法实例化(IOC)>属性值得依赖注入(DI)>@PostConstruct>InitializingBean>BeanFactoryPostProcess>BeanPostPorcess.postProcessBeforeInitialization>bean的init方法>BeanPostPorcess.postProcessAfterInitialization>...>destory>@PreConstruct

 

* BeanFactoryPostProcess 
  处理bean factory 拿到 依赖注入完毕的bean工厂,通过beanfactorypostprocess接口拿到 bean工厂,并拿到特定的BeanDefinition 并修改bean的属性 如scope lazyinit ... 具体看 bean definition

 * BeanPostProcess
   
   调用InitializingBean接口的afterProperties()

   在bean的init方法前后执行
   对Bean进行处理
   
* InitializingBean

在所有的Bean注入成功后执行一次方法


* FactoryBean 
创建复杂的bean对象


* PostFactoryBean

* @PostConstruct @PreConstruct

@PostConstruct @PreConstruct是java5 引入的注解,针对serlvet生命周期的扩展点
服务器加载servlet类->servlet 构造函数的运行加载 -> 执行@postconstruct的方法 只会执行一次-> init (servlet)只执行一次->service()每次请求都会执行并且根据请求类型调用不同的doPost/doGet->destory销毁serlvet对象->执行@preConstruct的方法 只执行一次-> 服务器卸载serlvet





 BeanDefinitionRegistryPostProcessor 在所有的BeanFactoryPostProcessor中最先执行甚至可以修改 其他BeanFactoryPostProcessor



### Aop的原理

### Transaction

#### 声明式事务底层

#### 事务处理

#### 传播监控

#### springJdbc 写ORM

### SpringMvc框架源码解读

dispatcherservlet  

多个请求之间的单例controller如何保证 变量不被污染 

requestContextHolder

ThreadLocal 保证多线程之间状态bean的安全性



#### 与IOC容器整合

#### HandlerMapping

#### HandlerAdapter

#### ViewResolver

#### Controller调用原理

#### 动态参数匹配原理

## Mybatis框架源码解读

### Mybatis的配置和使用

[Mybatis 官网中文文档](http://www.mybatis.org/mybatis-3/zh/index.html)

[Mybatis Spring 官网文档](http://www.mybatis.org/spring/zh/index.html)

### Mybatis 手册解读

#### 配置

##### properties

属性设置 

username password url driver

1. 直接设置properties节点里 property的值
2. 设置方式可以通过 设置properties节点的 resource 属性引入 property文件
3. sqlSessionFactoryBuilder.build(reader, props) / SqlSessionFactoryBuilder.build(reader, environment, props);设置属性

属性设置有3种方式,这三种方式的加载顺序为从上到下,相同的name的property后面会覆盖前面

MyBatis 3.4.2 之后的版本可以 设置 properties相应property的默认值

此设置默认是关闭的 需要设置

```xml
 <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- Enable this feature -->
```

默认值的设置方式如下

```xml
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${db:username?:ut_user}"/>
</dataSource>
```

默认分割符号时: 如果需要变更为其他符号

```xml
<property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- Change default value of separator -->
```

此时默认符号为?:

##### settings

| setting                   | 描述                                             | 合法值      | 默认值 |
| ------------------------- | :----------------------------------------------- | ----------- | ------ |
| cacheEnabled              | 用于全局的开启关闭该配置文件所属的mapper内的缓存 | true\|false | true   |
| lazyLoadingEnabled        | 懒加载                                           |             |        |
| aggressiveLazyLoading     |                                                  |             |        |
| multipleResultSetsEnabled |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |



### Mybatis源码编译以及第一次debug trace

1. 工具IDEA
2. 源码的下载与配置
3. 编写自己的列子并debug测试

### Mybatis Plugin

在Configuration获取parameterHandler/resultSetHandler/statementHandler/Executor

会调用interceptorChain.pluginAll()

```java
public Object pluginAll(Object target) { 
    // 循环代理所有插件  
    for (Interceptor interceptor : interceptors) {                  target = interceptor.plugin(target);                                      
        }  
    return target;
}
```

可以看到这边迭代调用所有的Interceptor的plugin方法

```java
default Object plugin(Object target) {  
return Plugin.wrap(target, this); //调用jdk 动态代理生成代理后的executor 或者其他
}
```

这边时调用Plugin的wrap方法，并将原对象 和 inteceptor传入

```java
public static Object wrap(Object target, Interceptor interceptor) {  
	Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);  
	Class<?> type = target.getClass();  
	Class<?>[] interfaces = getAllInterfaces(type, signatureMap);  
	if (interfaces.length > 0) {    
//创建代理后的executor,并传入 代理前后动作    
		return Proxy.newProxyInstance(       
			type.getClassLoader(), interfaces,       
			new Plugin(target, interceptor, signatureMap));    
	}  
	return target;
}
```

获取拦截器上的全部注解拦截接口 的类型与 其方法（根据方法名称 和 形参确定唯一方法）存入signtureMap（key为拦截的接口类型，value为拦截方法们的set） , 并生成代理后的对象，并获取拦截器上所有注解接口类 中 符合 所有原对象类所实现的接口 为interfaces，最后生成代理后的对象，代理后的对象同样实现了原对象所有的接口，并在方法调用前会invoke Plugin的invoke方法。

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 
    //实现拦截  
    try {    
        Set<Method> methods = signatureMap.get(method.getDeclaringClass());   
        if (methods != null && methods.contains(method))
        {      
            return interceptor.intercept(new Invocation(target, method, args));   
        }    
        return method.invoke(target, args);  
    } catch (Exception e) {   
        throw ExceptionUtil.unwrapThrowable(e); 
    }
}
```

判断当前拦截方式是否存在在signtureMap及是否为我们拦截器注解所声明需要拦截的接口和方法，如果是的话调用

```interceptor.intercept(new Invocation(target, method, args));``` 否则原方法调用返回

此interceptor即为我们的拦截器所实现的拦截操作

因为可以获取到mappedStatement所以可以获取Configuration所以可以再次定制化Configuration中所有属性比如数据库源实现读写分离

### Mybatis下1对多 多对多 嵌套结果 嵌套查询

一对多结果集映射 联合主键

```xml
<resultMap>

    <id property="connectionkey"  column="connectionkey" jdbcType="VARCHAR"/>

    <result property="connectionkey"  column="connectionkey" jdbcType="VARCHAR"/>

        <collection>

            <id property="connectionid1"  column="connectionkey" jdbcType="VARCHAR"/>

            <id property="connectionid2"  column="connectionkey" jdbcType="VARCHAR"/>

            <result property="connectionkey"  column="connectionkey" jdbcType="VARCHAR"/>

            <result property="other"  column="other" jdbcType="VARCHAR"/>

        </collection>

</resultMap>
```



### 一级缓存 二级缓存 使用场景和选择策略

### Mybatis 与 spring集成

### Mybatis事务


# 性能提升架构技术

## 分布式架构思维

## ZooKeeper

## Nginx

## 消息中间件概述

### 消息队列性能比较

https://blog.csdn.net/mxw2552261/article/details/80222176

## ActiveMQ

## RabbitMQ

## RocketMQ

## Kafka

## Elastic

### ElasticSearch

### Logstash

### Kibana

## ELK

# 高效存储

## Redis

#### 基本数据结构

string/list/set/sorted set/hash

 redis3.2版本开始支持GEO（地理位置的数据格式） 

redis5.0开始支持流 类似于MQ

#### pipeline模式

pipeline模式下set/get 每秒可达50万

非pipeline模式下set/get可达12万

#### 分布式锁

#### AOF RDB

#### 读写分离

#### cluster

#### 哨兵 数据丢失

#### 缓存击穿 雪崩

#### 批量查询优化

#### 集群twemproxy codis

## 缓存解决方案实战

## mongoDB

## Mysql高可用

## Mysql高并发
1. 分库分表 
2. 读写分离 
3. 主从备份 
4. 主从容灾无缝切换
### Mycat

### Sharding-Sphere

### Sharding-JDBC

### Sharding-Proxy

## FastDFS
文件存储系统

# 分布式扩展到为服务架构

## 从RPC开始

## RMI

### RPC 与 RMI 的区别

RPC（远程过程调用）和RMI（远程方法调用）是两种可以让用户从一台电脑调用不同电脑上面的方法的的机制（也可以称作规范、协议）。两者的主要不同是他们的使用方式或者称作范式，RMI使用面向对象的范式，也就是用户需要知道他调用的对象和对象中的方法；RPC不是面向对象也不能处理对象，而是调用具体的子程序。

RPC是一个基于C语言的相对较旧的协议，因此也就继承了C语言的范式，使用RPC，你可以像调用一个本地方法一样调用远程的方法，由RPC处理调用过程的复杂操作，RMI的功能和RPC基本一样。但是和RPC只传输一个过程调用不同，RMI需要传输对象的引用以及调用的方法。RMI是用Java开发的，运行在Java虚拟机上，因此它的用途是调用远程计算机上的java应用程序

RMI 是基于java编写 运行于jvm，所以不支持跨语言，RPC基于C编写面向过程调用，所以支持跨语言。

## DUBBO

## WebService

## Spring Boot

## Spring Cloud Netflix

## Spirng Cloud Alibaba

### Nacos

### Sky Walking

### Sentinel

### Seata

## Docker

### 常用命令

docker search

### 启动centos虚拟机

docker run --rm -d -i -t centos:centos7.5.1804 /bin/bash
### Docker 的常见问题
##### Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

```sh
systemctl daemon-reload

systemctl restart docker.service
```
## Kubernetes

## Service Mesh

# 分布式方案及团队协助工具

## 分布式事务解决方案

## 单点登陆方案

### 问题背景

### 页面跨域问题

### Session跨域共享问题

### Session的扩展

### JWT(Json Web Tokens)

#### 资讯

[官网资讯](https://jwt.io)

[手册](./books/json_web_tokens_handbook.pdf)

## 分布式任务调度方案

## Maven

### 官网资讯

官网地址为[Maven官网资料地址](https://maven.apache.org/)

### Maven项目依赖管理

### Maven的安装与配置

### Maven的使用入门

### Maven的聚合与继承

多项目的聚合有助于更加方便的对多项目生命周期进行统一管理

多项目的继承有助于项目坐标与依赖的统一管理,同时也减少了重复依赖的问题

TODO

### Maven生命周期

### Maven插件

#### 概述

此部分打算直接开发一款Maven插件进行学习

#### [项目地址](https://github.com/OnlyPiglet/AutoJunit)

#### 项目目标

开发一款可以自动生成给予junit的插件

### Maven模板

Maven模板archetype,类似于word的doct excel xlst的概念

援引官方的解释

> In short, Archetype is a Maven project templating toolkit. An archetype is defined as an original pattern or model from which all other things of the same kind are made. The names fits as we are trying to provide a system that provides a consistent means of generating Maven projects. Archetype will help authors create Maven project templates for users, and provides users with the means to generate parameterized versions of those project templates.

制作模板，需要在pom.xml中添加制作模板的插件

```xml
<plugin>    
	<groupId>org.apache.maven.plugins</groupId>    
	<artifactId>maven-archetype-plugin</artifactId>    
	<version>2.2</version>
</plugin>
<plugin>    
	<groupId>org.apache.maven.plugins</groupId>    
	<artifactId>maven-compiler-plugin</artifactId>    
	<version>3.1</version>    
	<configuration>        
		<compilerVersion>1.8</compilerVersion>        
		<skip>true</skip>    
	</configuration>
</plugin>
```

1. 将mvn bin目录下拷贝一份mvn.cmd 和 mvnDebug.cmd 并重命名 mvn.bat 和 mvnDebug.bat

2. 进入已有项目的根目录{home}(pom.xml所在目录），执行如下命令

```bash
mvn archetype:create-from-project
```

3. 进入{home}\target\generated-sources\archetype，执行如下命令

```bash
mvn install
```

### 仓库及版本管理

### 私服-Nexus

## Jenkins

## Git
### 参考文献
[git-workflow.pdf](./books/git-workflow.pdf)

![git-workflow.png](./img/git/git-workflow.png)
![git-workflow.pdf](./img/git/merge--no-ff.png)
### 概念
远程仓库 -> 本地仓库 -> 项目
#### 常见操作流程

1. git clone
2. git commit
3. git master 主分支用于构建发布
4. git branch develop master 针对主干之路开辟分支用于解决特定问题
5. git checkout develop 切换到开发分支
6. 进行开发 或者 bug 修复
7. 团队个人操作 git fetch develop -> git checkout develop->git merge FETCH_HEAD / git pull develop develop 多人合作时,定时进行代码的合并,防止产生代码冲突
8.  团队leader git checkout -b release develop 使用最新开发版创建用于发布前内部测试组使用的发布分支 并切回develop
9.  团队leader git add -> git commit 提交develop的change至本地仓库
11. 团队leader git push origin develop 将最新版develop推送至远程仓库,并确定没有与他人冲突
13. 团队leader git merge --no-ff   保留合并流程
14. 团队leader git push origin release 将release版本推送至远程仓库 供测试人员下载使用
15. 确认没有问题 更新release版本分支至master并 打包 推送  master 和 tag 至远程仓库  | 如果master 已经在新版本开发过程中 直接跟据远程release制作tag并上传至远程仓库 后期在与 master合并
16. git checkout master -> git pull release master -> git tag v0.2 -> git push origin master -> git push origin --tags | 或者 git pull release release -> git checkout release -> git tag v0.2 -> git push (origin)--tags 

# Shell

## 服务器远程文件目录拷贝

### 命令

scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/

scp -r /opt/soft/ root@192.168.120.204:/opt/soft/

### 问题

使用root登入可能会被拒绝，设置参数为/etc/ssh/sshd_config中的PermitRootLogin 为 yes

需要给被操作的服务器文件目录登入用户的写权限

# 其他附件

[全球各大时区UTC](./books/Timezones.xlsx)



