

# 架构师成长之路

## 前言
借用一下一张图

![如侵必删](./img/previous.PNG)

#  架构师筑基必备技能
## 并发编程进阶

### 线程共享和协作

1. CPU核心数，线程数，时间片轮转机制解读

  

  - CPU核心数 

    CPU核心数分为 物理CPU，单CPU上的核心数，以及逻辑CPU，具体区别可以查询[CPU逻辑核心数和物理核心数是什么意思?](https://zhidao.baidu.com/question/568786289.html)	在Java 中可以通过 ```Runtime.getRuntime().availableProcessors()``` 获取为逻辑CPU的数量为我们所说的CPU核心数。

  - 线程数 线程是CPU可以调度的最小单元，对于多线程线程数量的合理设置就显得很关键了，线程数过少可能不能发挥CPU的全部效能，线程数过大又会产生上下文切换反而会降低效能。关于线程数量的设置，在我观察中一般有两种策略，一种较为笼统简单，还有一种较为精准，首先谈第一种策略

    ##### 简单策略

    将CPU的效能转换为完成任务所需时间，用时越少代表效能越高，设定```任务所需用时=CPU用时+IO用时```

    根据其中CPU用时和IO用时占比不同分为 CPU密集型 IO密集型。对用CPU密集型的任务，线程数设置为**CPU核心数+1**因为使用CPU的时间较多，不建议设置过多线程数，导致频繁切换上下文；对于IO密集型的线程数设置为**CPU核心数*2**，因为CPU会长时间处于空闲状态所以可以设置多一些线程数，增加CPU的使用效能。此种策略的简单方面有二，其一是设置线程数量的公式较为简陋，其二是没有考虑到系统的其他性能如文件句柄上限的数量等

    ##### 复杂策略

    可以参考[Programming Concurrency on the JVM](./books/Programming Concurrency on the JVM.pdf)中Page32的一段话

    ```
    Number of threads = Number of Available Cores / (1 - Blocking Coefficient)
    ```

    > where the blocking coefficient is between 0 and 1.
    >
    > A computation-intensive task has a blocking coefficient of 0, whereas an IO-intensive task has a value close to 1—a fully blocked task is doomed, so we don’t have to worry about the value reaching 1.
    >
    > To determine the number of threads, we need to know two things:
    >
    > • The number of available cores
    > • The blocking coefficient of tasks
    >
    > The first one is easy to determine; we can look up that information, even at runtime, as we saw earlier. It takes a bit of effort to determine the blocking coefficient. We can try to guess it, or we can use profiling tools or the java.lang.management API to determine the amount of time a thread spends on system/IO operations vs. on CPU-intensive tasks.

  ​      这里的```(Blocking Coefficient)阻塞系数=IO用时/CPU用时+IO用时```，这里还提到了可以使用```java.lang.management```包中的工具检测程序CPU的使用时间，相关的[ThreadMXBean API链接](https://docs.oracle.com/javase/8/docs/api/)我写了一个列子如代码清单1-1

  ```java
  import java.lang.management.ManagementFactory;
  import java.time.LocalTime;
  import java.util.concurrent.TimeUnit;
  
  public class TaskTest implements Runnable{
  
      private static volatile boolean loop = true;
  
      public void run() {
          LocalTime end = null;
          LocalTime start = LocalTime.now();
          int IOSUMTIME = 5;
          try{
              //CPU计算
              cal(1000000);
  
              //模拟IO用时
              TimeUnit.SECONDS.sleep(IOSUMTIME);
  
              end = LocalTime.now();
  
          }catch (Exception e) {
  
              e.fillInStackTrace();
  
          }finally {
              System.out.println("总计耗时: " +( end.toNanoOfDay() - start.toNanoOfDay() / 1000000000.0) + "s");
              double total_cpu = ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime()/1000000000.0;
              double user_cpu = ManagementFactory.getThreadMXBean().getCurrentThreadUserTime()/1000000000.0;
              System.out.println("总CPU耗时: " + total_cpu + "s");
              System.out.println("用户态CPU耗时: "+user_cpu +"s");
              System.out.println("IO耗时:"+IOSUMTIME+"s");
              double block_efficent = IOSUMTIME/(IOSUMTIME+total_cpu);
              System.out.println("阻塞系数: "+block_efficent);
              int cores = Runtime.getRuntime().availableProcessors();
              System.out.println("系统可用逻辑CPU核心数量:" + cores);
              System.out.println("此任务最佳线程数: " + cores/(1-block_efficent));
  
          }
  
  
      }
  
  
      public void cal(long lopp_cyc){
  
          double sum = 0;
  
          for(int i = 0;i<lopp_cyc;i++){
  
              sum = sum + i * i + Math.pow(2.0,Double.valueOf(i));
  
          }
  
      }
  }
  ```

  <center>代码清单1-1</center>
  运行结果如下

  ```
  总计耗时: 7.2238589927767E13s
  总CPU耗时: 0.71567s
  用户态CPU耗时: 0.702647s
  IO耗时:5s
  阻塞系数: 0.8747880825869933
  系统可用逻辑CPU核心数量:4
  此任务最佳线程数: 31.945840960219083
  ```

* 时间片轮转机制

  时间片轮转机制即单个CPU核心会不停的切换不同的线程，进程进行运行，由此产生了上文所说的上下文切换的问题。

2. synchronized/volatile/ThreadLocal

  [Java8全部官方文档](https://docs.oracle.com/javase/8/docs/)

  * synchronized

    **原子性 顺序性 可见性**

    **可重入**

    [Chapter17.1 Synchronization](./books/jls8.pdf#page=660&zoom=100,0,89)

    > The Java programming language provides multiple mechanisms for
    > communicating between threads. The most basic of these methods is
    > synchronization, which is implemented using monitors. Each object in Java is
    > associated with a monitor, which a thread can lock or unlock. Only one thread at
    > a time may hold a lock on a monitor. Any other threads attempting to lock that
    > monitor are blocked until they can obtain a lock on that monitor. **A thread t may
    > lock a particular monitor multiple times; each unlock reverses the effect of one
    > lock operation.**

    此段文献中明确说明了同一个线程是可以对同一个监视器拿锁多次。**(Synchronization是可重入的)**

    [Chapter3.14 Synchronization底层实现细节](./books/jvms8.pdf)

    > Synchronization in the Java Virtual Machine is implemented by monitor entry and
> exit, either explicitly (by use of the monitorenter and monitorexit instructions) or
    > implicitly (by the method invocation and return instructions).
> For code written in the Java programming language, perhaps the most common
    > form of synchronization is the  synchronized method. **A  synchronized method is**
    > **not normally implemented using monitorenter and monitorexit. Rather, it is simply**
    > **distinguished in the run-time constant pool by the  ACC_SYNCHRONIZED flag, which**
    > **is checked by the method invocation instructions (§2.11.10).**



此段说明了对于同步代码块使用的是monitorenter 与 monitorexit ,但对于同步方法略有不同使用的是常量池里的ACC_SYNCHRONIZED 标志位辨别同步。

**死锁的发生**

1. 持有D锁的线程A在等待B锁，持有B锁的线程C在等待D锁，接下来通过代码演示

```java
   package thread_share;
       
   public class A_Task implements Runnable {
       private Object a;
   
       private Object c;
   
       public A_Task(Object a,Object c){
           this.a = a;
           this.c = c;
       }
   
       @Override
       public void run() {
   
           synchronized (a){
   
               Flag.A_Ready = true;
   
               System.out.println("A_Task get a");
   
               while(!Flag.A_Ready || !Flag.B_Ready){
   
               }
               synchronized (c){
   
                   System.out.println("A_Task get c");
   
               }
   
           }
   
       }
   }
```




​    
```java
 package thread_share;
 public class B_Task implements Runnable {
 	private Object a;

    private Object c;
    public B_Task(Object c,Object a){

        this.a = a ;
        this.c = c;

    }

    @Override
    public void run() {

        synchronized (c){

            Flag.B_Ready = true;

            System.out.println("B_Task get c");

            while(!Flag.A_Ready || !Flag.B_Ready){

            }
            synchronized (a){

                System.out.println("B_Task get a");

            }

        }

    }
}


```


​    
```java
package thread_share;
public class Flag {
	public static volatile boolean A_Ready = false;
    public static volatile boolean B_Ready = false;
}

```


​    
```java
 package thread_share;
 public  class Test {
 	public static void main(String[] args) {

        Object a = new Object();

        Object c = new Object();

        new Thread(new A_Task(a,c)).start();

        new Thread(new B_Task(c,a)).start();
  		    }
 }
```




最后的结果截图如下

![deadlock_1](./img/deadlock_1.png)

从结果中可以看出A_Task进展到拿对象c的锁这一步停滞不前，B_Task进展到到拿a的锁这一步停滞不前，原因就是发生死锁了。

知道了死锁如何避免死锁的

这里直接参考[死锁，死锁的四个必要条件以及处理策略](https://blog.csdn.net/wljliujuan/article/details/79614019)

死锁的四个必要条件为

#### 互斥条件：

进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

#### 不可剥夺条件:

进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

#### 请求与保持条件：

进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

#### 循环等待条件:预防死锁

存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。

直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。

Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。

#### 预防死锁

**以上这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。**

****

再次分析一下 互斥条件和不可剥夺 为synchronized 的实现原理无法改变，可以从请求与保持条件,循环等待条件

  * volatile

    顺序性 可见性

    [JMM模型](https://www.jianshu.com/p/47f999a7c280)

    Happen Before原则

    - 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。
  - 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。
    
    - volatile的happen-before原则：对一个volatile变量的读操作happen-before对此变量的任意操作(当然也包括写操作了)。
  - happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
    - 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。
    - 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
    - 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。
    - 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。
    
    
    32位机器上 Long和Double的写诗非原子操作，读在JSR133后是原子操作之前也是非原子操作，因为Long和Double是4字节64位

  * ThreadLocal

    Thread->ThreadLocalMap->Entry[]->Entry WeakReference<ThreadLocal<?>>->key->value

    死锁 内存泄露

    线程上下文事务回滚
    
    connection
    数据库连接池的应用
    
    #### Description
   ```java
    public class DaoTemplate{
    
    ThreadLocal<Connection> conection_local = new ThreadLocal<Connection>();
    
    private getConnction(){
    
       if(conection_local.get() == null){
          
          conection_local.set(ConnectionManager.getConection());
       
       }else{
       
       return conection_local.get();
       
       } 
    }
    private closeConnction(){   
        if(conection_local.get() != null){    
        conection_local.remove();
        }   
    }
    abstract void run(Connection connection);
    
    protected void bussiness(){
      try{ 
         run(getConnection());
      }catch(EXception e)
      {
        throw new SQLExcpetion();
      }finally{
        closeConnction();
      }
     }   
    }
  ```

3. wait/notify/notifyAll/Join

   wait/notify/notifyAll/Join 的底层实现也是基于mintoerenter 与 mointoerexit 所以必须要在同步代码块中进行使用  

### 线程池

#### 线程池的使用

[阿里云Java开发手册](./books/java.pdf)

#### 线程池底层原理

#### Executor原理

Executor 

Thread

ThreadFactory

ThreadPoolExecutor

Worker 

AbstractQueuedSynchronizer



AbortPolicy

DiscardPolicy

DiscardOldestPolicy



## JVM性能深度调优

## 网络编程与高校IO
### 零拷贝
![零拷贝](./img/io/zero-copy.png)

## 深入Tomcat底层

## MYSQL深度优化

MYSQL备份

mysqldump -hIP -pPORT -uUSERNAME -pPASSWORD DATABASENAME | gzip  >  BACKUPFILEPAT.gz

mysqldump -hIP -pPORT -uUSERNAME -pPASSWORD DATABASENAME <  BACKUPFILEPAT.sql

### MYSQL事务及隔离性级别

##### 参考

[何为脏读、不可重复读、幻读](http://ifeve.com/db_problem/)

##### 定义

事务是用于查询或修改数据库各项数据的最小执行单元

##### 特性

* 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。

* 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

* 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

* 持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

由于是最小的执行单元,所以天然具有原子性 与 一致性

持久性应该是属于数据库的特性,既然事务是对数据库各项数据的查询与修改那么也必然是具备持久性的

隔离性特性的产生的原因 有些类似于多线程共享资源的处理 但不完全一样,为了解决事务并发带来的问题，才有了事务规范中的四个事务隔离级别

有以下几种事务并发问题情况的出现

测试数据

```sql
insert into table value(1,5)
insert into table value(2,6)
insert into table value(3,3)
insert into table value(4,7)
```

1. 脏读

   ![脏读](./img/mysql/zangdu.png)

   是指一个事务读取到了其他事务没有提交的数据

   会话1在会话2 update 后读到的age为 10 ,但是 会话2 可能update 后 不commit 执行 rollback

2. 不可重复读

   ![不可重复读](./img/mysql/bukechongfudu.png)

   一个事务内多次根据同一个查询条件查询出来的同一行记录的值不一样

   会话1在第一次读到的age是5,然后会话2 update 为 10 并且 提交 会话1 再次读取 age变为 10 ,两次读取结果不一样

3. 幻读

   ![幻读](./img/mysql/huandu.png)

   一个事务内多次根据同个条件查出来的记录行数不一样

   会话1第一次查询结果为2,会话2 insert 新数据,会话1再次查询 结果为 3

##### 隔离级别与问题

针对隔离性各大数据库厂商有着自己的解决方案,主要有以下几种

```
TRANSACTION_NONE                  不支持事务
TRANSACTION_READ_COMMITTED        支持事务               不防止 脏读 不可重复读 幻读
TRANSACTION_READ_UNCOMMITTED      防脏读                不防止 不可重复读 幻读
TRANSACTION_REPEATABLE_READ       防脏读 不可重复读       不防止 幻读
TRANSACTION_SERIALIZABLE          防脏读 不可重复读 幻读
```

Mysql 在 防止不可重复读 是存在一些争议的

![不可重复读争议](./img/mysql/bukechongfuduzhengyi.png)

TODO

## 架构基础必备Linux

# 设计思想解读和开源框架

## 六大原则

## 结构型模式

## 创建型模式

## 行为型模式

## Spring5源码解读

### 源码下载安装

使用idea下载最新的Spring版本

进入spring-core目录执行下面两个命令

`gradle objenesisRepackJar`

`gradle cglibRepackJar`

因为spring-core模块依赖着两个包,但是这两个包饼没有被打包进来需要手动加入依赖

我们一定会用到spring-context模块,此时我们需要先修改spring-context模块的build.gradle将其中的 compile(project(":spring-aop"))注释,暂时用不到,还有将optional(project(":spring-instrument"))修改为compile(project(":spring-instrument"))

接下来开始第一次的
---


 定义bean标签>将bean标签解析成BeanDefinition>BeanFactoryPostProcess>调用构造方法实例化(IOC)>属性值得依赖注入(DI)>@PostConstruct>InitializingBean>BeanPostPorcess.postProcessBeforeInitialization>bean的init方法>BeanPostPorcess.postProcessAfterInitialization>...>destory>@PreConstruct
 
 

* BeanFactoryPostProcess 
  处理bean factory 拿到 依赖注入完毕的bean工厂,通过beanfactorypostprocess接口拿到 bean工厂,并拿到特定的BeanDefinition 并修改bean的属性 如scope lazyinit ... 具体看 bean definition
 
 * BeanPostProcess
   在bean的init方法前后执行
   对Bean进行处理

* InitializingBean

在所有的Bean注入成功后执行一次方法


* FactoryBean 
创建复杂的bean对象


* PostFactoryBean

* @PostConstruct @PreConstruct

@PostConstruct @PreConstruct是java5 引入的注解,针对serlvet生命周期的扩展点
服务器加载servlet类->servlet 构造函数的运行加载 -> 执行@postconstruct的方法 只会执行一次-> init (servlet)只执行一次->service()每次请求都会执行并且根据请求类型调用不同的doPost/doGet->destory销毁serlvet对象->执行@preConstruct的方法 只执行一次-> 服务器卸载serlvet


## SpringMvc框架源码解读

## Mybatis框架源码解读

### Mybatis的配置和使用

[Mybatis 官网中文文档](http://www.mybatis.org/mybatis-3/zh/index.html)

[Mybatis Spring 官网文档](http://www.mybatis.org/spring/zh/index.html)

### Mybatis 手册解读

#### 配置

##### properties

属性设置 

username password url driver

1. 直接设置properties节点里 property的值
2. 设置方式可以通过 设置properties节点的 resource 属性引入 property文件
3. sqlSessionFactoryBuilder.build(reader, props) / SqlSessionFactoryBuilder.build(reader, environment, props);设置属性

属性设置有3种方式,这三种方式的加载顺序为从上到下,相同的name的property后面会覆盖前面

MyBatis 3.4.2 之后的版本可以 设置 properties相应property的默认值

此设置默认是关闭的 需要设置

```xml
 <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- Enable this feature -->
```

默认值的设置方式如下

```xml
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${db:username?:ut_user}"/>
</dataSource>
```

默认分割符号时: 如果需要变更为其他符号

```xml
<property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- Change default value of separator -->
```

此时默认符号为?:

##### settings

| setting                   | 描述                                             | 合法值      | 默认值 |
| ------------------------- | :----------------------------------------------- | ----------- | ------ |
| cacheEnabled              | 用于全局的开启关闭该配置文件所属的mapper内的缓存 | true\|false | true   |
| lazyLoadingEnabled        | 懒加载                                           |             |        |
| aggressiveLazyLoading     |                                                  |             |        |
| multipleResultSetsEnabled |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |
|                           |                                                  |             |        |



### Mybatis源码编译以及第一次debug trace

1. 工具IDEA
2. 源码的下载与配置
3. 编写自己的列子并debug测试


### Mybatis Plugin


# 性能提升架构技术

## 分布式架构思维

## ZooKeeper

## Nginx

## 消息中间件概述

## ActiveMQ

## RabbitMQ

## RocketMQ

## Kafka

## Elastic

### ElasticSearch

### Logstash

### Kibana

## ELK

# 高效存储

## Redis

## 缓存解决方案实战

## mongoDB

## Mysql高可用

## Mysql高并发
1. 分库分表 
2. 读写分离 
3. 主从备份 
4. 主从容灾无缝切换
### Mycat

### Sharding-Sphere

### Sharding-JDBC

### Sharding-Proxy

## FastDFS
文件存储系统

# 分布式扩展到为服务架构

## 从RPC开始

## RMI

## DUBBO

## WebService

## Spring Boot

## Spring Cloud Netflix

## Spirng Cloud Alibaba

### Nacos

### Sky Walking

### Sentinel

### Seata

## Docker

### 常用命令

docker search

### 启动centos虚拟机

docker run --rm -d -i -t centos:centos7.5.1804 /bin/bash
### Docker 的常见问题
##### Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

```sh
systemctl daemon-reload

systemctl restart docker.service
```
## Kubernetes

## Service Mesh

# 分布式方案及团队协助工具

## 分布式事务解决方案

## 单点登陆方案

### 问题背景

### 页面跨域问题

### Session跨域共享问题

### Session的扩展

### JWT(Json Web Tokens)

#### 资讯

[官网资讯](https://jwt.io)

[手册](./books/json_web_tokens_handbook.pdf)

## 分布式任务调度方案

## Maven

### 官网资讯

官网地址为[Maven官网资料地址](https://maven.apache.org/)

### Maven项目依赖管理

### Maven的安装与配置

### Maven的使用入门

### Maven的聚合与继承

多项目的聚合有助于更加方便的对多项目生命周期进行统一管理

多项目的继承有助于项目坐标与依赖的统一管理,同时也减少了重复依赖的问题

TODO

### Maven生命周期

### Maven插件

#### 概述

此部分打算直接开发一款Maven插件进行学习

#### [项目地址](https://github.com/OnlyPiglet/AutoJunit)

#### 项目目标

开发一款可以自动生成给予junit的插件

### Maven模板

Maven模板archetype,类似于word的doct excel xlst的概念

援引官方的解释

> In short, Archetype is a Maven project templating toolkit. An archetype is defined as an original pattern or model from which all other things of the same kind are made. The names fits as we are trying to provide a system that provides a consistent means of generating Maven projects. Archetype will help authors create Maven project templates for users, and provides users with the means to generate parameterized versions of those project templates.

制作模板，需要在pom.xml中添加制作模板的插件

```xml
<plugin>    
	<groupId>org.apache.maven.plugins</groupId>    
	<artifactId>maven-archetype-plugin</artifactId>    
	<version>2.2</version>
</plugin>
<plugin>    
	<groupId>org.apache.maven.plugins</groupId>    
	<artifactId>maven-compiler-plugin</artifactId>    
	<version>3.1</version>    
	<configuration>        
		<compilerVersion>1.8</compilerVersion>        
		<skip>true</skip>    
	</configuration>
</plugin>
```

1. 将mvn bin目录下拷贝一份mvn.cmd 和 mvnDebug.cmd 并重命名 mvn.bat 和 mvnDebug.bat

2. 进入已有项目的根目录{home}(pom.xml所在目录），执行如下命令

```bash
mvn archetype:create-from-project
```

3. 进入{home}\target\generated-sources\archetype，执行如下命令

```bash
mvn install
```

### 仓库及版本管理

### 私服-Nexus

## Jenkins

## Git
### 参考文献
[git-workflow.pdf](./books/git-workflow.pdf)

![git-workflow.png](./img/git/git-workflow.png)
![git-workflow.pdf](./img/git/merge--no-ff.png)
### 概念
远程仓库 -> 本地仓库 -> 项目
#### 常见操作流程

1. git clone
2. git commit
3. git master 主分支用于构建发布
4. git branch develop master 针对主干之路开辟分支用于解决特定问题
5. git checkout develop 切换到开发分支
6. 进行开发 或者 bug 修复
7. 团队个人操作 git fetch develop -> git checkout develop->git merge FETCH_HEAD / git pull develop develop 多人合作时,定时进行代码的合并,防止产生代码冲突
8.  团队leader git checkout -b release develop 使用最新开发版创建用于发布前内部测试组使用的发布分支 并切回develop
9.  团队leader git add -> git commit 提交develop的change至本地仓库
11. 团队leader git push origin develop 将最新版develop推送至远程仓库,并确定没有与他人冲突
13. 团队leader git merge --no-ff 
14. 团队leader git push origin release 将release版本推送至远程仓库 供测试人员下载使用
15. 确认没有问题 更新release版本分支至master并 打包 推送  master 和 tag 至远程仓库  | 如果master 已经在新版本开发过程中 直接跟据远程release制作tag并上传至远程仓库 后期在与 master合并
16. git checkout master -> git pull release master -> git tag v0.2 -> git push origin master -> git push origin --tags | 或者 git pull release release -> git checkout release -> git tag v0.2 -> git push (origin)--tags 

# Shell

## 服务器远程文件目录拷贝

### 命令

scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/

scp -r /opt/soft/ root@192.168.120.204:/opt/soft/

### 问题

使用root登入可能会被拒绝，设置参数为/etc/ssh/sshd_config中的PermitRootLogin 为 yes

需要给被操作的服务器文件目录登入用户的写权限

# 其他附件

[全球各大时区UTC](./books/Timezones.xlsx)



